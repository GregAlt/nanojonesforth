NanoJonesForth is a project to shrink the assembly language from jonesforth,
moving words into forth source while maintaining compatibility.

I'm trying to balance a few somewhat conflicting goals:
   - Minimal nanojonesforth.S file size
   - Simple and straightforward nanojonesforth.S file (no obfuscations)
   - Minimal stripped .elf result
   - No assembly language outside of forth definitions
   - Minimal number of defcode words
   - No complex defcode words
   - Minimal number of defvar and defconst words
   - After reducing defcode words, minimal number of defword compiled forth words
   - Good performance is not a goal, but I'll avoid gratuitous bad performance
   - Compatibility with jonesforth, including all tests passing
       (with minor adjustments for specific offsets in exception and stack tests)
   - No handcrafted .elf - the elf will be built with standard tools and stripped

Final .elf file is 1772 bytes, using standard tools to build and strip.

nanojonesforthcore.f is larger and more complicated than it needs to be, but it was 
built up incrementally to avoid the big jump from what the .S provides and what
jonesforth.f expects.

nanojonesforth.S provides these words:

   Asm word for executable entrypoint:
	start

   Core, simple asm words:
	DOCOL DROP, SWAP, DUP, 1+, -, *, /MOD, <, NAND, EXIT, @, !, C@, C!, 
	RSP@, RSP!, DSP@, DSP!, EXECUTE, SYSCALL3

   Compiled forth words:
	QUIT0, WORD0, KEY0, FIND0, 0BRANCH, COLD_START

   Int variable words:
	HERE, LATEST, S0

   Block array variable words:
	RETURN_STACK, WB (word buffer)

   Constant words:
	INIT_SZ (data segment size), R0 (initial return stack top), G0 (0), G_4 (-4)

   File IO constant words: (defined in <asm/unistd.h>)
	SYS_EXIT, SYS_OPEN, SYS_CLOSE, SYS_READ, SYS_WRITE, SYS_CREAT, SYS_BRK

Or rather, it provides shortened 3-char names for these, with some ugliness to
ensure each is unique.	

Notably, it does not include INTERPRET, :, or NUMBER. And the versions of WORD, KEY,
and FIND are very limited, with no support for comments, and support for only exactly 
3-character names. FIND assumes it will succeed and things crash if it doesn't.

Another oddity is that the dictionary format isn't quite what you'd expect with
jonesforth. Instead of:

[4 Byte LINK][1 Byte flags/len][1-31 Bytes Name][0-3 Bytes padding][4 Bytes codeword]

I ignore flagsm, force len==3, force exactly 3-char names strings, and then force
4 bytes padding before the codeword:

[4 Byte LINK][1 Byte len==3][3 Bytes Name][4 Bytes padding][4 Bytes codeword]

This has a few advantages:
- the codeword is at a fixed 12 byte offset, which is easier to calculate
- names can be compared with simple int compare rather than a string compare
- the 4 bytes padding lets us fix up the original assembly words in place.

The pseudo-forth in nanojonesforthcore.f gradually builds up funcationality and
fixes up the dictionary to be what jonesforth expects, with arbitrary name lengths,
flags, and the appropriate padding for alignment.

As a starting point, I started with the version of jonesforth from:
   https://github.com/nornagon/jonesforth/tree/master 

which describes itself as:

This is a mirror of Richard WM Jones's excellent literate x86 assembly
implementation of Forth, more on which here:
http://rwmj.wordpress.com/2010/08/07/jonesforth-git-repository/
